<?php

/**
 * @file
 * Install, update, and uninstall functions for the AVC Development module.
 */

use Drupal\node\Entity\Node;
use Drupal\user\Entity\User;

/**
 * Implements hook_install().
 */
function avc_devel_install() {
  // Create sample content on module install.
  avc_devel_create_sample_content();
}

/**
 * Creates sample content for AVC asset types.
 */
function avc_devel_create_sample_content() {
  $admin = User::load(1);
  $node_storage = \Drupal::entityTypeManager()->getStorage('node');

  // Sample Documents.
  $documents = [
    [
      'title' => 'Data Privacy Policy',
      'body' => '<p>This document outlines the data privacy practices for AV Commons community members.</p><h3>Scope</h3><p>This policy applies to all personal data collected and processed by the community.</p><h3>Data Collection</h3><p>We collect only the minimum necessary personal information to provide community services.</p><h3>Data Protection</h3><p>All personal data is encrypted and stored securely in compliance with applicable regulations.</p>',
    ],
    [
      'title' => 'Member Handbook',
      'body' => '<p>Welcome to AV Commons! This handbook provides essential information for new and existing members.</p><h3>Getting Started</h3><p>After registration, complete your profile and introduce yourself in the welcome forum.</p><h3>Community Guidelines</h3><p>Treat all members with respect. Share knowledge freely. Collaborate openly.</p><h3>Support</h3><p>For assistance, contact a community leader or post in the support forum.</p>',
    ],
    [
      'title' => 'Workflow Best Practices',
      'body' => '<p>This guide covers best practices for using the workflow system effectively.</p><h3>Task Assignment</h3><p>Assign tasks to specific users or groups based on expertise and availability.</p><h3>Progress Tracking</h3><p>Update task status promptly to keep stakeholders informed.</p><h3>Communication</h3><p>Use task comments to document decisions and provide context for reviewers.</p>',
    ],
    [
      'title' => 'Translation Style Guide',
      'body' => '<p>Standards for maintaining consistency across all translations.</p><h3>Tone</h3><p>Use formal but accessible language. Maintain the spiritual depth of source material.</p><h3>Terminology</h3><p>Consult the approved glossary for standard translations of key terms.</p><h3>Review Process</h3><p>All translations undergo peer review and theological verification.</p>',
    ],
    [
      'title' => 'Annual Report 2024',
      'body' => '<p>Summary of community activities and achievements in 2024.</p><h3>Highlights</h3><ul><li>500+ new members joined the community</li><li>50 documents completed and published</li><li>10 translation projects finished</li><li>3 new workflow templates created</li></ul><h3>Looking Ahead</h3><p>Plans for 2025 include expanded translation efforts and improved collaboration tools.</p>',
    ],
  ];

  // Sample Resources.
  $resources = [
    [
      'title' => 'Vatican II Documents',
      'body' => '<p>Official documents from the Second Vatican Council.</p><p>An essential resource for understanding the foundations of modern Catholic teaching and liturgical reform.</p><p><a href="https://www.vatican.va/archive/hist_councils/ii_vatican_council/">Access Documents</a></p>',
    ],
    [
      'title' => 'Catechism of the Catholic Church',
      'body' => '<p>The official compendium of Catholic doctrine.</p><p>This authoritative text covers beliefs, sacraments, moral life, and prayer.</p><p><a href="https://www.vatican.va/archive/ENG0015/_INDEX.HTM">Read Online</a></p>',
    ],
    [
      'title' => 'Liturgy of the Hours App',
      'body' => '<p>Mobile application for praying the Divine Office.</p><p>Available for iOS and Android. Features audio recordings and multiple language options.</p><p>Includes morning prayer, evening prayer, and night prayer for daily use.</p>',
    ],
    [
      'title' => 'Scripture Study Tools',
      'body' => '<p>Collection of resources for biblical study and meditation.</p><ul><li>Bible commentaries from Church Fathers</li><li>Greek/Hebrew lexicons</li><li>Study guides and reading plans</li><li>Audio recordings of Scripture</li></ul>',
    ],
  ];

  // Sample Projects.
  $projects = [
    [
      'title' => 'Liturgy Translation Project',
      'body' => '<p>Translating liturgical texts into modern languages while preserving theological accuracy.</p><h3>Scope</h3><p>This project covers the complete liturgical calendar including seasonal prayers and feast days.</p><h3>Team</h3><p>Translation Team, Theology Group, Editorial Board</p><h3>Timeline</h3><p>Expected completion: Q4 2025</p>',
    ],
    [
      'title' => 'Community Guidelines Revision',
      'body' => '<p>Updating and clarifying community guidelines for 2025.</p><h3>Goals</h3><ul><li>Simplify language for clarity</li><li>Add new sections on digital etiquette</li><li>Incorporate member feedback</li><li>Align with updated privacy regulations</li></ul>',
    ],
    [
      'title' => 'Formation Course Development',
      'body' => '<p>Creating comprehensive online formation courses for new members.</p><h3>Modules</h3><ol><li>Introduction to Community Life</li><li>Spiritual Foundations</li><li>Practical Service</li><li>Deepening Commitment</li></ol><h3>Format</h3><p>Self-paced online learning with weekly live sessions.</p>',
    ],
  ];

  $created = ['documents' => 0, 'resources' => 0, 'projects' => 0];

  // Create documents.
  foreach ($documents as $doc) {
    if (!_avc_devel_node_exists($doc['title'], 'avc_document')) {
      $node = Node::create([
        'type' => 'avc_document',
        'title' => $doc['title'],
        'body' => ['value' => $doc['body'], 'format' => 'basic_html'],
        'uid' => $admin->id(),
        'status' => 1,
      ]);
      $node->save();
      $created['documents']++;
    }
  }

  // Create resources.
  foreach ($resources as $res) {
    if (!_avc_devel_node_exists($res['title'], 'avc_resource')) {
      $node = Node::create([
        'type' => 'avc_resource',
        'title' => $res['title'],
        'body' => ['value' => $res['body'], 'format' => 'basic_html'],
        'uid' => $admin->id(),
        'status' => 1,
      ]);
      $node->save();
      $created['resources']++;
    }
  }

  // Create projects.
  foreach ($projects as $proj) {
    if (!_avc_devel_node_exists($proj['title'], 'avc_project')) {
      $node = Node::create([
        'type' => 'avc_project',
        'title' => $proj['title'],
        'body' => ['value' => $proj['body'], 'format' => 'basic_html'],
        'uid' => $admin->id(),
        'status' => 1,
      ]);
      $node->save();
      $created['projects']++;
    }
  }

  // Create workflow tasks for the new content.
  avc_devel_create_sample_workflow_tasks();

  // Create guild skill content if module is enabled.
  avc_devel_create_sample_skill_content();

  \Drupal::logger('avc_devel')->info('Created sample content: @docs documents, @res resources, @proj projects', [
    '@docs' => $created['documents'],
    '@res' => $created['resources'],
    '@proj' => $created['projects'],
  ]);
}

/**
 * Creates sample workflow tasks for AVC assets.
 */
function avc_devel_create_sample_workflow_tasks() {
  if (!\Drupal::entityTypeManager()->hasDefinition('workflow_task')) {
    return;
  }

  $task_storage = \Drupal::entityTypeManager()->getStorage('workflow_task');
  $node_storage = \Drupal::entityTypeManager()->getStorage('node');
  $admin = User::load(1);

  // Get all AVC asset nodes.
  $nids = $node_storage->getQuery()
    ->condition('type', ['avc_document', 'avc_resource', 'avc_project'], 'IN')
    ->accessCheck(FALSE)
    ->execute();

  $nodes = $node_storage->loadMultiple($nids);
  $created = 0;

  // Task templates with varying statuses.
  $task_templates = [
    ['title' => 'Initial Review', 'status' => 'completed'],
    ['title' => 'Content Edit', 'status' => 'in_progress'],
    ['title' => 'Theological Review', 'status' => 'pending'],
    ['title' => 'Final Approval', 'status' => 'pending'],
  ];

  foreach ($nodes as $node) {
    // Check if tasks already exist for this node.
    $existing = $task_storage->getQuery()
      ->condition('node_id', $node->id())
      ->accessCheck(FALSE)
      ->execute();

    if (!empty($existing)) {
      continue;
    }

    $weight = 0;
    foreach ($task_templates as $template) {
      $task = $task_storage->create([
        'title' => $template['title'] . ' - ' . $node->getTitle(),
        'description' => [
          'value' => 'Review and process: ' . $node->getTitle(),
          'format' => 'basic_html',
        ],
        'node_id' => $node->id(),
        'weight' => $weight,
        'assigned_type' => 'user',
        'assigned_user' => $admin->id(),
        'status' => $template['status'],
        'uid' => $admin->id(),
      ]);
      $task->save();
      $created++;
      $weight++;
    }
  }

  \Drupal::logger('avc_devel')->info('Created @count sample workflow tasks', ['@count' => $created]);
}

/**
 * Helper function to check if a node exists.
 */
function _avc_devel_node_exists($title, $type) {
  $existing = \Drupal::entityTypeManager()->getStorage('node')
    ->loadByProperties(['title' => $title, 'type' => $type]);
  return !empty($existing);
}

/**
 * Creates sample guild skill content.
 */
function avc_devel_create_sample_skill_content() {
  // Check if avc_guild module is enabled.
  if (!\Drupal::moduleHandler()->moduleExists('avc_guild')) {
    return;
  }

  $entity_type_manager = \Drupal::entityTypeManager();

  // Check if skill-related entity types exist.
  if (!$entity_type_manager->hasDefinition('skill_level') ||
      !$entity_type_manager->hasDefinition('member_skill_progress') ||
      !$entity_type_manager->hasDefinition('skill_credit') ||
      !$entity_type_manager->hasDefinition('level_verification')) {
    \Drupal::logger('avc_devel')->warning('Guild skill entity types not available.');
    return;
  }

  $created = [
    'skill_terms' => 0,
    'skill_levels' => 0,
    'progress_records' => 0,
    'credits' => 0,
    'verifications' => 0,
  ];

  // 1. Create guild skills taxonomy terms if they don't exist.
  $term_storage = $entity_type_manager->getStorage('taxonomy_term');
  $vocab_storage = $entity_type_manager->getStorage('taxonomy_vocabulary');

  if ($vocab_storage->load('guild_skills')) {
    $skill_names = [
      'Technical Writing',
      'Translation',
      'Editing',
      'Proofreading',
      'Theology',
      'Research',
    ];

    $skill_ids = [];
    foreach ($skill_names as $name) {
      // Check if term exists.
      $existing = $term_storage->loadByProperties([
        'vid' => 'guild_skills',
        'name' => $name,
      ]);

      if (!empty($existing)) {
        $skill_ids[] = key($existing);
        continue;
      }

      $term = $term_storage->create([
        'vid' => 'guild_skills',
        'name' => $name,
      ]);
      $term->save();
      $skill_ids[] = $term->id();
      $created['skill_terms']++;
    }

    // 2. Create skill levels for each guild.
    if (!empty($skill_ids)) {
      $group_storage = $entity_type_manager->getStorage('group');
      $config_service = \Drupal::service('avc_guild.skill_configuration');

      // Get all groups.
      $group_ids = $group_storage->getQuery()->accessCheck(FALSE)->execute();

      foreach ($group_ids as $group_id) {
        $group = $group_storage->load($group_id);
        if (!$group) {
          continue;
        }

        // Create levels for 2-3 random skills per guild.
        $selected_skills = array_slice($skill_ids, 0, min(3, count($skill_ids)));

        foreach ($selected_skills as $skill_id) {
          $skill = $term_storage->load($skill_id);
          if (!$skill) {
            continue;
          }

          // Check if levels already exist.
          $existing = $config_service->getSkillLevels($group, $skill);
          if (!empty($existing)) {
            continue;
          }

          // Create default levels.
          $levels = $config_service->createDefaultLevels($group, $skill);
          $created['skill_levels'] += count($levels);
        }
      }

      // 3. Create member skill progress for guild members.
      $progress_storage = $entity_type_manager->getStorage('member_skill_progress');

      foreach ($group_ids as $group_id) {
        $group = $group_storage->load($group_id);
        if (!$group) {
          continue;
        }

        // Get skill levels for this guild.
        $guild_skills = $config_service->getGuildSkillLevels($group);
        if (empty($guild_skills)) {
          continue;
        }

        // Get members.
        $members = $group->getMembers();
        if (empty($members)) {
          continue;
        }

        foreach ($members as $membership) {
          $user = $membership->getUser();
          if (!$user) {
            continue;
          }

          // Create progress for 1-2 random skills.
          $selected_skill_ids = array_rand($guild_skills, min(2, count($guild_skills)));
          if (!is_array($selected_skill_ids)) {
            $selected_skill_ids = [$selected_skill_ids];
          }

          foreach ($selected_skill_ids as $skill_id) {
            $skill = $term_storage->load($skill_id);
            if (!$skill) {
              continue;
            }

            // Check if progress already exists.
            $existing = $progress_storage->getQuery()
              ->accessCheck(FALSE)
              ->condition('user_id', $user->id())
              ->condition('guild_id', $group->id())
              ->condition('skill_id', $skill->id())
              ->execute();

            if (!empty($existing)) {
              continue;
            }

            // Randomly assign level (0-3) and credits.
            $current_level = rand(0, 3);
            $current_credits = $current_level === 0 ? rand(0, 30) : rand(0, 100);

            $progress = $progress_storage->create([
              'user_id' => $user->id(),
              'guild_id' => $group->id(),
              'skill_id' => $skill->id(),
              'current_level' => $current_level,
              'current_credits' => $current_credits,
              'level_achieved_date' => strtotime('-' . rand(10, 180) . ' days'),
              'pending_verification' => FALSE,
            ]);

            $progress->save();
            $created['progress_records']++;
          }
        }
      }

      // 4. Create skill credits for member progress.
      $credit_storage = $entity_type_manager->getStorage('skill_credit');
      $progress_ids = $progress_storage->getQuery()->accessCheck(FALSE)->execute();

      if (!empty($progress_ids)) {
        $progress_records = $progress_storage->loadMultiple($progress_ids);
        $source_types = ['task_review', 'endorsement', 'manual'];

        foreach ($progress_records as $progress) {
          // Create 5-10 credits per member skill.
          $num_credits = rand(5, 10);

          for ($i = 0; $i < $num_credits; $i++) {
            $source_type = $source_types[array_rand($source_types)];
            $credit_amount = rand(1, 15);

            $credit = $credit_storage->create([
              'user_id' => $progress->get('user_id')->target_id,
              'guild_id' => $progress->get('guild_id')->target_id,
              'skill_id' => $progress->get('skill_id')->target_id,
              'credits' => $credit_amount,
              'source_type' => $source_type,
              'notes' => 'Sample credit generated by avc_devel module.',
              'created' => strtotime('-' . rand(1, 180) . ' days'),
            ]);

            $credit->save();
            $created['credits']++;
          }
        }
      }

      // 5. Create sample level verifications.
      $verification_storage = $entity_type_manager->getStorage('level_verification');

      // Get progress records where level > 0.
      $progress_ids_with_levels = $progress_storage->getQuery()
        ->accessCheck(FALSE)
        ->condition('current_level', 0, '>')
        ->execute();

      if (!empty($progress_ids_with_levels)) {
        $progress_records = $progress_storage->loadMultiple($progress_ids_with_levels);

        // Create 2-3 pending verifications.
        $pending_count = 0;
        foreach (array_slice($progress_records, 0, 3, TRUE) as $progress) {
          if ($pending_count >= 3) {
            break;
          }

          $guild = $progress->getGuild();
          $skill = $progress->getSkill();
          if (!$guild || !$skill) {
            continue;
          }

          $current_level = $progress->getCurrentLevel();
          $target_level = $current_level + 1;

          // Get level config for target level.
          $level_config = $config_service->getLevelConfig($guild, $skill, $target_level);
          if (!$level_config) {
            continue;
          }

          // Check if verification already exists.
          $existing = $verification_storage->getQuery()
            ->accessCheck(FALSE)
            ->condition('user_id', $progress->get('user_id')->target_id)
            ->condition('guild_id', $guild->id())
            ->condition('skill_id', $skill->id())
            ->condition('target_level', $target_level)
            ->condition('status', 'pending')
            ->execute();

          if (!empty($existing)) {
            continue;
          }

          $verification = $verification_storage->create([
            'user_id' => $progress->get('user_id')->target_id,
            'guild_id' => $guild->id(),
            'skill_id' => $skill->id(),
            'target_level' => $target_level,
            'status' => 'pending',
            'verification_type' => $level_config->getVerificationType(),
            'votes_required' => $level_config->getVotesRequired(),
            'votes_approve' => 0,
            'votes_deny' => 0,
            'votes_defer' => 0,
          ]);

          $verification->save();
          $created['verifications']++;
          $pending_count++;
        }

        // Create 2-3 approved verifications (historical).
        $approved_count = 0;
        foreach (array_slice($progress_records, 3, 3, TRUE) as $progress) {
          if ($approved_count >= 3) {
            break;
          }

          $guild = $progress->getGuild();
          $skill = $progress->getSkill();
          if (!$guild || !$skill) {
            continue;
          }

          $current_level = $progress->getCurrentLevel();
          if ($current_level === 0) {
            continue;
          }

          // Get level config for current level (the one they achieved).
          $level_config = $config_service->getLevelConfig($guild, $skill, $current_level);
          if (!$level_config) {
            continue;
          }

          $verification = $verification_storage->create([
            'user_id' => $progress->get('user_id')->target_id,
            'guild_id' => $guild->id(),
            'skill_id' => $skill->id(),
            'target_level' => $current_level,
            'status' => 'approved',
            'verification_type' => $level_config->getVerificationType(),
            'votes_required' => $level_config->getVotesRequired(),
            'votes_approve' => $level_config->getVotesRequired(),
            'votes_deny' => 0,
            'votes_defer' => 0,
            'created' => strtotime('-' . rand(30, 180) . ' days'),
            'completed' => strtotime('-' . rand(20, 170) . ' days'),
            'feedback' => 'Approved based on demonstrated competency. Good work!',
          ]);

          $verification->save();
          $created['verifications']++;
          $approved_count++;
        }
      }
    }
  }

  \Drupal::logger('avc_devel')->info('Created sample guild skill content: @terms terms, @levels skill levels, @progress progress records, @credits credits, @verifications verifications', [
    '@terms' => $created['skill_terms'],
    '@levels' => $created['skill_levels'],
    '@progress' => $created['progress_records'],
    '@credits' => $created['credits'],
    '@verifications' => $created['verifications'],
  ]);
}

/**
 * Implements hook_uninstall().
 */
function avc_devel_uninstall() {
  // Optionally clean up sample content on uninstall.
  // This is commented out to preserve content if module is reinstalled.
  // avc_devel_cleanup_sample_content();
}
